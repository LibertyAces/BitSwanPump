import argparse
import os
import json
import pprint
import re
import datetime
import time
import requests
import jwt

'''

	BS integrity checker

	The main role of integrity check is to find whether the hashed events consist the same
	information as the unhashed. The output of bsintegrity is the set of recent and previous hashes
	and number of items on which has / has not been integrity approved.

	Below is the brief description of functionality.

	Integrity checker:

	1] Take one ElasticSearch index - for which the integrity is going to be analyzed

	2] Check total count of index items

	3] Request ElasticSearch for all items
		- by series of requests where every iteration has "n" items which is defined by
		the user (items_size). Number of iterations is set by the count of items in index 
		and by items_size

	4] For every item
		a] checks its signature (hash) with the items
		b] saves to HashSet the set of actual hash and previous hash (if there is any)
		previous hash is the hash of the previous entry (there might be some)

	5] At the end of the iteration, there will be a set of hash pairs which could be examined
	e.g. from the chart perspective

'''

class Integrity:

	def __init__(self):
		# Hit and Miss count to see how many items (objects) were checked and with hit or miss result
		self.HitCount = 0
		self.MissCount = 0
		# Progress Bar Event counter - helps to visualize progress bar
		self.PBCounter = 0
		# Global variable of previous hash
		self.PrevActHash = None
		# Hashes which where integrity has not been approved are stored here and eventually printed at the end of the process
		self.HashSet = {}


	# Return count of all items for given index
	def get_items_count_in_index(self, es_url, index_name):
		url = es_url + '/{}/_count'.format(index_name)
		r = requests.get(url, 
			json={'query':{'bool':{'must':{'match_all':{}}}}}, 
			headers={'Content-Type': 'application/json'})
		if r.status_code != 200:
			print("Failed to fetch data from ElasticSearch: {} from {}\n{}".format(r.status_code, url, r.text))
			return None
		else:
			msg = r.json()
			return msg['count']


	# Check for hash
	# act_prev_hash: previous hash of actual event is assigned to this variable
	# self.PrevActHash: hash of actual event is assigned to this global variable, initially set to None
	def object_check(self, JSONobject):
		act_prev_hash = JSONobject["_source"]['previous_hash']
		# Comparison between previous hash of actual event and hash of previous event
		if act_prev_hash == self.PrevActHash:
			self.HitCount += 1
		else:
			self.MissCount +=1
			self.HashSet.update({str(self.MissCount): {"ActualPrevious": act_prev_hash, "PreviousActual": self.PrevActHash}})
		self.PrevActHash = JSONobject["_source"]["hash"]


	# Progress bar
	def progress_bar(self, iteration, total, prefix='', suffix='', decimals=1, length=100, fill='â–ˆ', printEnd="\r"):
	    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
	    filledLength = int(length * iteration // total)
	    bar = fill * filledLength + '-' * (length - filledLength)
	    print('\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix), end = printEnd)
	    # Print new line after the end of iteration
	    if iteration == total: 
	        print()


	# On command method
	def COMMAND_check(self, URL, index, items_size, hash_name, prev_hash_name, hash_id):
		count = self.get_items_count_in_index(URL, index)
		url = URL + '/{}/_search'.format(index)
		# Initialize hash
		if hash_name == '' or hash_name is None:
			hash_name = "hash"
		if prev_hash_name == '' or prev_hash_name is None:
			prev_hash_name = "previous_hash"
		if hash_id == '' or hash_id is None:
			hash_id = "hash_id"
		# Exit app when number of indices in ES is None
		if count is None:
			return
		if count > 0:
			self.progress_bar(0, count, prefix='Progress:', suffix='Complete', length=50)
			# Initialize search_after value
			search_after = 0
			while True:
				r = requests.post(url, 
					json={"size":items_size,"search_after":[search_after],"sort":[{hash_id:{"order":"asc"}}],'query': {'bool': {'must': {'match_all': {}}}}}, 
					headers={'Content-Type': 'application/json'})
				
				if r.status_code != 200:
					print("Failed to fetch data from ElasticSearch: {} from {}\n{}".format(r.status_code, url, r.text))
					break

				msg = r.json()
				hits = msg['hits']['hits']
				if len(hits) == 0:
					break

				# Checking hashes by object
				for JSONobject in hits:
					self.PBCounter += 1
					self.object_check(JSONobject)

				# Creating cursor to ES using "search_after"
				# In while loop, it search for another n events in ES 
				# after request get response from ES
				# "search_after" is based on items_size 
				search_after += int(items_size)

		    	# Update Progress Bar
				time.sleep(0.1)
				self.progress_bar(self.PBCounter, count, prefix='Progress:', suffix='Complete', length=50)


		if not self.HashSet == {}:
			print(self.HashSet)
		print('\n')
		print('Integrity has been approved on {} items\n'.format(str(self.HitCount)))
		print('Integrity has not been enthroned on {} items\n'.format(str(self.MissCount)))
		  


def parse_cmdline():

	# Parse args
	parser = argparse.ArgumentParser(
		formatter_class=argparse.RawDescriptionHelpFormatter,
		description='''
		Check integrity on ElasticSearch hashes.\n
		-----------------------------------------------------
		''')

	subparsers = parser.add_subparsers(help='commands')


	# An check command
	check_parser = subparsers.add_parser('check', help='check on integrity of hashed events')
	check_parser.add_argument('URL', action='store', help='a ElasticSearch URL, e.g. http://localhost:9200')
	check_parser.add_argument('index', action='store', help='a ElasticSearch index, e.g. my_index-01')
	check_parser.add_argument('items_size', action='store', help='a Items to be loaded from ES in one iteration, e.g. 50')
	check_parser.add_argument('--hash_name', action='store', help='a Optional argument Hash key name, e.g. hash')
	check_parser.add_argument('--prev_hash_name', action='store', help='a Optional argument Previous hash key name, e.g. previous_hash')
	check_parser.add_argument('--hash_id', action='store', help='a Optional argument Hash ID key name, e.g. hash_id')
	check_parser.set_defaults(COMMAND='check')

	return parser.parse_args()


def main():
	# Get arguments
	args = parse_cmdline()

	# Call the command
	if 'COMMAND' not in args:
		print("Please select a command: check")
		print("For more information see --help")
		return 1

	if args.COMMAND == 'check':
		return Integrity().COMMAND_check(args.URL, args.index, args.items_size, 
			args.hash_name, args.prev_hash_name, args.hash_id)


if __name__ == '__main__':
	main()
