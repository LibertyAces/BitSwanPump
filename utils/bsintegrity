import argparse
import os
import json
import pprint
import re
import datetime
import time
import requests

'''

	BS integrity

	The main role of integrity check is to find whether the actual hashed event consist the same
	information as it is stored in the previous event in its previous hash. The output of bsintegrity is 
	the number of items on which has / has not been integrity approved. Items where integrity has not been
	approved also returns the set of actual and previous hash.

	Below is the brief description of functionality.

	Integrity checker:

	1] Take one ElasticSearch index - for which the integrity is going to be analyzed

	2] Check total count of index items

	3] Request ElasticSearch for all items
		- by series of requests where every iteration has "n" items which is defined by
		the user (items_size). Number of iterations is set by the count of items in index 
		and by items_size

	4] For every item
		a] checks its signature (hash) with the items
		b] Integrity enricher add to the event the set of actual hash and previous hash
		   Previous hash is the hash of the previous entry
		   bspump.integrity.integrityenricher

	5] At the end of the iteration, there will be a set of hash pairs which could be examined
	e.g. from the chart perspective

'''

class Integrity:

	def __init__(self):
		# Hit and Miss count to see how many items (objects) were checked and with hit or miss result
		self.HitCount = 0
		self.MissCount = 0
		# Progress Bar Event counter - helps to visualize progress bar
		self.PBCounter = 0
		# Global variable of previous hash
		self.PrevActHash = None
		# Hashes which where integrity has not been approved are stored here and eventually printed at the end of the process
		self.HashSet = {}
		self.PreviousHashSet = {}


	# Return count of all items for given index
	def get_items_count_in_index(self, es_url, index_name):
		url = es_url + '/{}/_count'.format(index_name)
		r = requests.get(url, 
			json={'query':{'bool':{'must':{'match_all':{}}}}}, 
			headers={'Content-Type': 'application/json'})
		if r.status_code != 200:
			print("Failed to fetch data from ElasticSearch: {} from {}\n{}".format(r.status_code, url, r.text))
			return None
		else:
			msg = r.json()
			return msg['count']


	# Signature comparison
	# act_prev_hash: previous hash of actual event is assigned to this variable
	# self.PrevActHash: hash of actual event is assigned to this global variable, initially set to None
	# def signature_comparison(self, JSONobject, hash_name, prev_hash_name):
	# 	act_prev_hash = JSONobject["_source"][str(prev_hash_name)]
	# 	# Comparison between previous hash of actual event and hash of previous event
	# 	if act_prev_hash == self.PrevActHash:
	# 		self.HitCount += 1
	# 	else:
	# 		self.MissCount +=1
	# 		self.HashSet.update({str(self.MissCount): {"ActualPrevious": act_prev_hash, "PreviousActual": self.PrevActHash}})
	# 	self.PrevActHash = JSONobject["_source"][str(hash_name)]


	# Progress bar
	def progress_bar(self, iteration, total, prefix='', suffix='', decimals=1, length=100, fill='â–ˆ', printEnd="\r"):
	    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
	    filledLength = int(length * iteration // total)
	    bar = fill * filledLength + '-' * (length - filledLength)
	    print('\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix), end = printEnd)
	    # Print new line after the end of iteration
	    if iteration == total: 
	        print()


	# # On command method
	# def COMMAND_check(self, URL, index, items_size, hash_name, prev_hash_name, hash_id):
	# 	print('ahoj2')
	# 	count = self.get_items_count_in_index(URL, index)
	# 	scroll_id = None
	# 	print('ahoj')
	# 	while True:
	# 		if scroll_id is None:
	# 			url = URL + '/{}/_search?scroll=1m'.format(index)
	# 			query = {"size":items_size}
	# 		else:
	# 			url = URL + "_search/scroll"
	# 			query = {"scroll":"1m","scroll_id": scroll_id}

	# 		r = requests.post(url, json=query)
	# 		if r.status_code != 200:
	# 			print("Failed to fetch data from ElasticSearch: {} from {}\n{}".format(r.status_code, url, r.text))
	# 			break

	# 		msg = r.json()

	# 		scroll_id = msg['_scroll_id']

	# 		hits = msg['hits']['hits']
	# 		if len(hits) == 0:
	# 			break

	# 		print(len(hits))

		 #    Update Progress Bar
			# time.sleep(0.1)
			# self.progress_bar(self.PBCounter, count, prefix='Progress:', suffix='Complete', length=50)


	def get_items(self, URL, index, items_size, hash_name ,prev_hash_name):
		count = self.get_items_count_in_index(URL, index)
		scroll_id = None
		print('Getting data from ElasticSearch')
		self.progress_bar(0, count, prefix='Download:', suffix='Complete', length=50)
		DBCounter = 0
		while True:
			if scroll_id is None:
				url = URL + '/{}/_search?scroll=1m'.format(index)
				query = {"size":items_size}
			else:
				url = URL + "/_search/scroll"
				query = {"scroll":"1m","scroll_id": scroll_id}

			r = requests.post(url, json=query)
			if r.status_code != 200:
				print("Failed to fetch data from ElasticSearch: {} from {}\n{}".format(r.status_code, url, r.text))
				break

			msg = r.json()

			scroll_id = msg['_scroll_id']

			hits = msg['hits']['hits']
			if len(hits) == 0:
				break

			for JSONobject in hits:
				DBCounter += 1
				self.HashSet[JSONobject["_source"][hash_name]] = JSONobject["_id"]
				self.PreviousHashSet[JSONobject["_source"][prev_hash_name]] = JSONobject["_id"] 


	     	# Update Progress Bar
			self.progress_bar(DBCounter, count, prefix='Download:', suffix='Complete', length=50)
 

	def COMMAND_check(self, URL, index, items_size, hash_name, prev_hash_name):
		# Initialize hash
		if hash_name == '' or hash_name is None:
			hash_name = "hash"
		if prev_hash_name == '' or prev_hash_name is None:
			prev_hash_name = "previous_hash"
		self.get_items(URL, index, items_size, hash_name, prev_hash_name)
		PBCounter = 0
		PBlen = len(self.PreviousHashSet)
		print('Checking for integrity')
		self.progress_bar(0, PBlen, prefix='Progress:', suffix='Complete', length=50)
		# Removing initial previous hash (set to None in enricher)
		A = self.PreviousHashSet.pop(None, None)
		self.HitCount += 1
		for key, value in self.HashSet.items():
			PBCounter += 1
			A = self.PreviousHashSet.pop(key, None)
			if A is not None:
				self.HitCount += 1
			else:
				self.MissCount += 1
			# Update Progress Bar
			self.progress_bar(PBCounter, PBlen, prefix='Progress:', suffix='Complete', length=50)
		
		if len(self.PreviousHashSet) > 0:
			print(self.PreviousHashSet)
			print('Integrity has not been ensured.')
			print('Number of items where integrity has not been ensured: {}\n'.format(str(self.MissCount)))
		else:
			print('Integrity has been ensured.')
			print('Number of items where integrity has been ensured: {}\n'.format(str(self.HitCount)))


def parse_cmdline():

	# Parse args
	parser = argparse.ArgumentParser(
		formatter_class=argparse.RawDescriptionHelpFormatter,
		description='''
		Check integrity on ElasticSearch hashes.\n
		-----------------------------------------------------
		''')

	subparsers = parser.add_subparsers(help='commands')


	# An check command
	check_parser = subparsers.add_parser('check', help='check on integrity of hashed events')
	check_parser.add_argument('URL', action='store', help='a ElasticSearch URL, e.g. http://localhost:9200')
	check_parser.add_argument('index', action='store', help='a ElasticSearch index, e.g. my_index-01')
	check_parser.add_argument('items_size', action='store', help='a Items to be loaded from ES in one iteration, e.g. 50')
	check_parser.add_argument('--hash_name', action='store', help='a Hash key name, e.g. --hash_name=hash')
	check_parser.add_argument('--prev_hash_name', action='store', help='a Previous hash key name, e.g. --prev_hash_name=previous_hash')
	check_parser.set_defaults(COMMAND='check')

	return parser.parse_args()


def main():
	# Get arguments
	args = parse_cmdline()

	# Call the command
	if 'COMMAND' not in args:
		print("Please select a command: check")
		print("For more information see --help")
		return 1

	if args.COMMAND == 'check':
		return Integrity().COMMAND_check(args.URL, args.index, args.items_size, 
			args.hash_name, args.prev_hash_name)


if __name__ == '__main__':
	main()
